# -*- coding: utf-8 -*-
"""MAT 220 Python Project 5 (Computer Graphics).ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1lxfxTsQtKHIh29LM93O6U1h3yYGkz2zS

# Python Project 5: Transformations and Computer Graphics

Reference pages 336 – 340 in Section 6.5 of textbook.

As we have seen in Chapter 6 of the book, we can use matrices to perform many different types of transformations.  One transformation we looked at was rotating vectors.  As many shapes can be comprised of vectors, we can actually rotate shapes by rotating the point vectors of that comprise the shape.

## Example: Rotation

The eight vertices of the rectangular prism shown at the right are:
$V_1= (0,0,0);  V_2=(2,0,0); V_3=(2,3,0); V_4=(0,3,0); V_5=(0,0,4); V_6=(2,0,4); V_7=(2,3,4); V_8=(0,3,4)$

Once again, we will be using Python (in a Jupyter notebook) to write the code to do this.

First, import libraries and define sympy variables. As preiously, we import numpy, sympy, and matplotlib. Along with scipy, these are significant scientific calculation and display libraries. This time, we will also import from the mplot3d library, so we can visualize 3D objects.
"""

# Initialization; Only need to run once.
from sympy import *
init_printing()
x, y, z, t = symbols('x y z t')
k, m, n = symbols('k m n', integer=True)
f, g, h = symbols('f g h', cls=Function)

import matplotlib.pyplot as plt
import numpy as np
from sympy.plotting.plot import MatplotlibBackend, Plot

from mpl_toolkits.mplot3d import Axes3D
import itertools

"""Now, we plot a wireframe of the 3D rectangular prism defined by these points. We iterate through the points, using numpy to make an array of points along each edge (between each vertex)."""

# Commented out IPython magic to ensure Python compatibility.
fig = plt.figure()
ax = fig.add_subplot(projection='3d')
# %matplotlib inline
pts = [(0,0,0),(2,0,0),(0,3,0),(0,0,4),(2,3,0),(2,0,4),(2,3,4),(0,3,4)]
idx_list = []
for p in pts:
    ax.scatter(p[0],p[1],p[2],zdir='z',c='r')
for idx, (a, b) in enumerate(itertools.product(pts,pts)):
    if [a[0]==b[0], a[1]==b[1], a[2]==b[2]].count(True)==2:
        idx_list.append(idx)
        x = np.linspace(a[0], b[0], 100)
        y = np.linspace(a[1], b[1], 100)
        z = np.linspace(a[2], b[2], 100)
        ax.plot(x, y, z)
ax.set_xlim3d(0,4)
ax.set_ylim3d(0,4)
ax.set_zlim3d(0,4);

"""Rotations:
Using a transformation matrix for a rotation of $θ=30°$ about the $z$-axis using the right-hand:

"""

T=Matrix([
[np.cos(np.pi/6),-np.sin(np.pi/6),0],
[np.sin(np.pi/6), np.cos(np.pi/6), 0],
[0,0,1]])

## We need the points to form columns, so apply the transpose after entering each point as a row.
C=Matrix([[0,0,0],[2,0,0],[0,3,0],[0,0,4],[2,3,0],[2,0,4],[2,3,4],[0,3,4]]).T

pprint(T.applyfunc(nsimplify)*C)

"""Notice the output above (because of the "applyfunc(nsimplify)" gives the rotated points with *exact* values.  I do want exact values, where appropriate.

Next, we use plot the rotated rectangular prism, reading off the points from each column. (See the line with "pts=". The transpose is applied again, turning each point into its own row.)
"""

fig1 = plt.figure()
import numbers
ax = fig1.add_subplot(projection='3d')
pts = [(a,b,c) for a,b,c in (T*C).T.tolist()]
for p in pts:
    p = [float(i) for i in p]
    ax.scatter(p[0],p[1],p[2],zdir='z',c='r')
for idx, (a, b) in enumerate(itertools.product(pts,pts)):
    if(idx in idx_list):
        idx_list.append(idx)
        x = np.linspace(a[0], b[0], 100)
        y = np.linspace(a[1], b[1], 100)
        z = np.linspace(a[2], b[2], 100)
        ax.plot(x, y, z)
ax.set_xlim3d(0,4)
ax.set_ylim3d(0,4)
ax.set_zlim3d(0,4);

"""The shape above is the same rectangular prism, rotated 30 degrees about the z-axis!

**Note**: Make sure that you check your tabbing in your code, that it matches the sample code. Python uses tabbing for structures like "if" and loops.

## Example: Scaling

Another linear transformation scales a view along the x, y, and z directions by factors $c_1$, $c_2$, and $c_3$, respectively.  

Given a point $P_1=(x_1,y_1,z_1)$ in the initial view, the point is moved to a new point $P_1'=(c_1 x_1,c_2 y_1,c_3 z_1)$ in the new view.  

This transformation may be carried out by multiplying the point $P_1$ as a column vector by matrix $S$ (which is a diagonal matrix, with the scale factors as the diagonal).

$ S= \begin{bmatrix}
c_1 & 0 & 0 \\
0 & c_2 & 0 \\
0 & 0 & c_3
\end{bmatrix}  $

## Example: Translation

Another transformation translates an object to a new position.

Given a point $P_1=(x_1,y_1,z_1)$ in the initial view, the point may be translated to a new point  $P_1^{'}=(x_1+d_1,y_1+d_2,z_1+d_3)$ by adding the translation vector $T=[d_1,d_2,d_3]$.

$P_1^{'} = P_1 + T$  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp; $P_1^{'} = \begin{bmatrix}x_1 \\ y_1 \\ z_1\end{bmatrix}+\begin{bmatrix}d_1 \\ d_2 \\ d_3\end{bmatrix}$

## Directions

+ As always, you must use the methods above. Do not use new codes or write your own.
+ If you choose to submit a separate document, copy your matrices and graphs into your document by taking screenshots of your code, matrices, and graphs.
+ Adjust your axes accordingly.
+ Be sure to show all code/commands you entered by copying and pasting them into your document (if applicable), and then saving it as a PDF.

## Problem 1

Use Python and a rotation matrix to find the coordinates of the vertices after the prism is rotated counterclockwise about the **z-axis** through:

+ $θ=60°$
+ $θ=90°$
+ $θ=150°$

Then plot the rotated prism with Python for each.

*Note: This is three separate rotations, and you should have three separate graphs.*
"""

## Theta = 60
init_printing()

T = Matrix([
    [np.cos(np.pi/3), -np.sin(np.pi/3), 0],
    [np.sin(np.pi/3),  np.cos(np.pi/3), 0],
    [0, 0, 1]
])

C = Matrix([
    [0,0,0],
    [2,0,0],
    [0,3,0],
    [0,0,4],
    [2,3,0],
    [2,0,4],
    [2,3,4],
    [0,3,4]
]).T

pprint(T.applyfunc(nsimplify) * C)

fig1 = plt.figure()
import numbers
ax = fig1.add_subplot(projection='3d')
pts = [(a,b,c) for a,b,c in (T*C).T.tolist()]
for p in pts:
    p = [float(i) for i in p]
    ax.scatter(p[0],p[1],p[2],zdir='z',c='r')
for idx, (a, b) in enumerate(itertools.product(pts,pts)):
    if(idx in idx_list):
        idx_list.append(idx)
        x = np.linspace(a[0], b[0], 100)
        y = np.linspace(a[1], b[1], 100)
        z = np.linspace(a[2], b[2], 100)
        ax.plot(x, y, z)
ax.set_xlim3d(-6, 6)
ax.set_ylim3d(-6, 6)
ax.set_zlim3d(0, 6);

## Theta = 90
T = Matrix([
    [np.cos(np.pi/2), -np.sin(np.pi/2), 0],
    [np.sin(np.pi/2),  np.cos(np.pi/2), 0],
    [0, 0, 1]
])

C = Matrix([
    [0, 0, 0],
    [2, 0, 0],
    [0, 3, 0],
    [0, 0, 4],
    [2, 3, 0],
    [2, 0, 4],
    [2, 3, 4],
    [0, 3, 4]
]).T

pprint(T.applyfunc(nsimplify) * C)

fig1 = plt.figure()
import numbers
ax = fig1.add_subplot(projection='3d')
pts = [(a,b,c) for a,b,c in (T*C).T.tolist()]
for p in pts:
    p = [float(i) for i in p]
    ax.scatter(p[0],p[1],p[2],zdir='z',c='r')
for idx, (a, b) in enumerate(itertools.product(pts,pts)):
    if(idx in idx_list):
        idx_list.append(idx)
        x = np.linspace(a[0], b[0], 100)
        y = np.linspace(a[1], b[1], 100)
        z = np.linspace(a[2], b[2], 100)
        ax.plot(x, y, z)
ax.set_xlim3d(-6, 6)
ax.set_ylim3d(-6, 6)
ax.set_zlim3d(0, 6);

## Theta = 150
T = Matrix([
    [np.cos(5*np.pi/6), -np.sin(5*np.pi/6), 0],
    [np.sin(5*np.pi/6),  np.cos(5*np.pi/6), 0],
    [0, 0, 1]
])

C = Matrix([
    [0, 0, 0],
    [2, 0, 0],
    [0, 3, 0],
    [0, 0, 4],
    [2, 3, 0],
    [2, 0, 4],
    [2, 3, 4],
    [0, 3, 4]
]).T

pprint(T.applyfunc(nsimplify) * C)

fig1 = plt.figure()
import numbers
ax = fig1.add_subplot(projection='3d')
pts = [(a,b,c) for a,b,c in (T*C).T.tolist()]
for p in pts:
    p = [float(i) for i in p]
    ax.scatter(p[0],p[1],p[2],zdir='z',c='r')
for idx, (a, b) in enumerate(itertools.product(pts,pts)):
    if(idx in idx_list):
        idx_list.append(idx)
        x = np.linspace(a[0], b[0], 100)
        y = np.linspace(a[1], b[1], 100)
        z = np.linspace(a[2], b[2], 100)
        ax.plot(x, y, z)
ax.set_xlim3d(-6, 6)
ax.set_ylim3d(-6, 6)
ax.set_zlim3d(0, 6);

"""Use Python and a rotation matrix to find the coordinates of the vertices after the prism is rotated counterclockwise about the **x-axis** through:

+ $θ=60°$
+ $θ=90°$
+ $θ=150°$

**You do <u>not</u> need to plot these. Just report the rotation matrix and the rotated vertices for each.**
"""

## Theta = 60
T = Matrix([
    [1, 0, 0],
    [0, np.cos(np.pi/3), -np.sin(np.pi/3)],
    [0, np.sin(np.pi/3),  np.cos(np.pi/3)]
])

C = Matrix([
    [0, 0, 0],
    [2, 0, 0],
    [0, 3, 0],
    [0, 0, 4],
    [2, 3, 0],
    [2, 0, 4],
    [2, 3, 4],
    [0, 3, 4]
]).T

pprint(T.applyfunc(nsimplify) * C)

## Theta = 90
T = Matrix([
    [1, 0, 0],
    [0, np.cos(np.pi/2), -np.sin(np.pi/2)],
    [0, np.sin(np.pi/2),  np.cos(np.pi/2)]
])

C = Matrix([
    [0, 0, 0],
    [2, 0, 0],
    [0, 3, 0],
    [0, 0, 4],
    [2, 3, 0],
    [2, 0, 4],
    [2, 3, 4],
    [0, 3, 4]
]).T

pprint(T.applyfunc(nsimplify) * C)

## Theta = 150
T = Matrix([
    [1, 0, 0],
    [0, np.cos(5*np.pi/6), -np.sin(5*np.pi/6)],
    [0, np.sin(5*np.pi/6),  np.cos(5*np.pi/6)]
])

C = Matrix([
    [0, 0, 0],
    [2, 0, 0],
    [0, 3, 0],
    [0, 0, 4],
    [2, 3, 0],
    [2, 0, 4],
    [2, 3, 4],
    [0, 3, 4]
]).T

pprint(T.applyfunc(nsimplify) * C)

"""Use Python and a rotation matrix to find the coordinates of the vertices after the prism is rotated counterclockwise about the **y-axis** through:

+ $θ=60°$
+ $θ=90°$
+ $θ=150°$

**You do <u>not</u> need to plot these. Just report the rotation matrix and the rotated vertices for each.**
"""

## Theta = 60
from sympy import *
import numpy as np
init_printing()

T = Matrix([
    [np.cos(np.pi/3), 0, np.sin(np.pi/3)],
    [0, 1, 0],
    [-np.sin(np.pi/3), 0, np.cos(np.pi/3)]
])

C = Matrix([
    [0, 0, 0],
    [2, 0, 0],
    [0, 3, 0],
    [0, 0, 4],
    [2, 3, 0],
    [2, 0, 4],
    [2, 3, 4],
    [0, 3, 4]
]).T

pprint(T.applyfunc(nsimplify) * C)

## Theta = 90
from sympy import *
import numpy as np
init_printing()

T = Matrix([
    [np.cos(np.pi/2), 0, np.sin(np.pi/2)],
    [0, 1, 0],
    [-np.sin(np.pi/2), 0, np.cos(np.pi/2)]
])

C = Matrix([
    [0, 0, 0],
    [2, 0, 0],
    [0, 3, 0],
    [0, 0, 4],
    [2, 3, 0],
    [2, 0, 4],
    [2, 3, 4],
    [0, 3, 4]
]).T

pprint(T.applyfunc(nsimplify) * C)

## Theta = 150
from sympy import *
import numpy as np
init_printing()

T = Matrix([
    [np.cos(5*np.pi/6), 0, np.sin(5*np.pi/6)],
    [0, 1, 0],
    [-np.sin(5*np.pi/6), 0, np.cos(5*np.pi/6)]
])

C = Matrix([
    [0, 0, 0],
    [2, 0, 0],
    [0, 3, 0],
    [0, 0, 4],
    [2, 3, 0],
    [2, 0, 4],
    [2, 3, 4],
    [0, 3, 4]
]).T

pprint(T.applyfunc(nsimplify) * C)

"""## Problem 2

Use Python and a single scaling matrix to:

+ Find the coordinates of the vertices after the prism is scaled by a factor of 2 in the x-direction, 4 in the y-direction, and 0.5 in the z-direction.
+ Then plot the scaled prism with Python.
"""

from sympy import *
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import itertools

init_printing()

# Scaling matrix
S = Matrix([
    [2, 0, 0],
    [0, 4, 0],
    [0, 0, 0.5]
])

# Original coordinate matrix (each column is a vertex)
C = Matrix([
    [0, 0, 0],
    [2, 0, 0],
    [0, 3, 0],
    [0, 0, 4],
    [2, 3, 0],
    [2, 0, 4],
    [2, 3, 4],
    [0, 3, 4]
]).T

# Apply scaling
result = S * C
pprint(result)

# code for this was not given, I did my best to automate points using for loops

fig = plt.figure()
ax = fig.add_subplot(projection='3d')

pts = [(a, b, c) for a, b, c in result.T.tolist()]
for p in pts:
    p = [float(i) for i in p]
    ax.scatter(p[0], p[1], p[2], c='r')

for a, b in itertools.product(pts, pts):
    if sum([a[i] == b[i] for i in range(3)]) == 2:
        x = np.linspace(a[0], b[0], 100)
        y = np.linspace(a[1], b[1], 100)
        z = np.linspace(a[2], b[2], 100)
        ax.plot(x, y, z)

ax.set_xlim3d(0, 5)
ax.set_ylim3d(0, 15)
ax.set_zlim3d(0, 3);
ax.set_title("Scaled Prism (x2, y4, z0.5)")
plt.show()

"""## Problem 3

Use Python and a single translation matrix to:

+ Find the coordinates of the vertices after the prism is translated 3 units in the x-direction, 4 units in the y-direction, and 2 units in the z-direction.  (Note:  You may set up a 3 by 8 transition matrix which consists of the entries that shift all of our vertices at once.)
+ Then plot the translated prism with Python.

**Note:** The size of your translation matrix matters! It should be 3x8.  Do not write your own code for this.  I am checking to see what you know about how matrices work and if you can modify the code to do the non-linear transformation.
"""

from sympy import *
import numpy as np
import matplotlib.pyplot as plt
from mpl_toolkits.mplot3d import Axes3D
import itertools

init_printing()

# Original vertices (each column is a point)
C = Matrix([
    [0, 0, 0],
    [2, 0, 0],
    [0, 3, 0],
    [0, 0, 4],
    [2, 3, 0],
    [2, 0, 4],
    [2, 3, 4],
    [0, 3, 4]
]).T

# Translation matrix: 3x8 matrix where each column is [3, 4, 2]
T = Matrix([[3]*8, [4]*8, [2]*8])

# Apply translation (element-wise addition)
result = C + T
pprint(result)

# code for this was not given, I did my best to automate points using for loops

fig = plt.figure()
ax = fig.add_subplot(projection='3d')

pts = [(a, b, c) for a, b, c in result.T.tolist()]
for p in pts:
    p = [float(i) for i in p]
    ax.scatter(p[0], p[1], p[2], c='r')

for a, b in itertools.product(pts, pts):
    if sum([a[i] == b[i] for i in range(3)]) == 2:
        x = np.linspace(a[0], b[0], 100)
        y = np.linspace(a[1], b[1], 100)
        z = np.linspace(a[2], b[2], 100)
        ax.plot(x, y, z)

ax.set_xlim3d(0, 10)
ax.set_ylim3d(0, 10)
ax.set_zlim3d(0, 10);
ax.set_title("Translated Prism (+3 x, +4 y, +2 z)")
plt.show()